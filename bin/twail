#!/usr/bin/perl
# purpose : like the unix "tail" command for Twitter
# TODO:
# - allow following arbitrary and multiple lists

my $usage = <<USAGE;

usage:
  $0 [--user u] [--pass p] [--color] [--debug] [--follow m] [--list l] [--timestamp] [--help]

where:
  --user      : is the Twitter user name
  --pass      : is the Twitter password (safer to use environment variable as below)
  --color     : ANSI color output
  --debug     : print some debugging output
  --follow    : refresh every m minutes, printing new tweets ala tail -f
  --list      : print statuses from a list you own
  --timestamp : print timestamp every update

examples:
  TWTUSER=scobleizer TWTPASS=overshare $0 -f 10 -c
  TWTUSER=questzero TWTPASS=uptheirons $0 -f 1 -c -l toptwenty 
USAGE

use Data::Dumper;
use Date::Parse;
use Encode;
use Getopt::Long;
use Net::Twitter;
use Term::ANSIColor;
use strict;
use warnings;

# handle args

my @options = qw(
  color
  debug
  follow=s
  help
  list=s
  pass=s
  user=s
);
my %args;
GetOptions(\%args, @options);
if ($args{help}) {
  print "$usage\n";
  exit 2;
}
my $user = $args{user} || $ENV{TWTUSER}; 
my $pass = $args{pass} || $ENV{TWTPASS}; 
unless ($user && $pass) {
  print "No user/password specified!\n$usage\n";
  exit 2;
}

my $statuses;
my $high_water = 1;
my %name_colors;
my @colors_foreground_screen_names = qw(
  cyan
  green
  magenta
  red
  yellow
);

my $nt = Net::Twitter->new(
  traits => [qw(
    API::Lists
    API::REST
  )],
  username => $user,
  password => $pass,
);

# for list mode, get the list id and verify the list actually exists

my @lists_found;
my $list_id;
if ($args{list}) {
  my $list_data;
  my $result = 'success';
  if ($args{debug}) {
    my $timestamp = localtime();
    print "$timestamp fetching lists for user $user ";
  }
  eval {
    $list_data = $nt->get_lists($user);
  };
  if ($@) {
    $result = 'failure';
    die $@;
  }
  if ($args{debug}) {
    print " $result\n";
  }
  if ($list_data) {
    foreach my $list (@{$list_data->{lists}}) {
      push @lists_found, $list->{name};
      if ($args{list} eq $list->{name}) {
        $list_id = $list->{id};
      }
    }
    unless ($list_id) {
      print "available lists are: " . join ', ', @lists_found;
      print "\n";
      exit 1;
    }
  }
}

# the big twail loop (if in follow mode)

while ( 1 ) {

  # list mode

  if ($args{list}) {
    my $result = 'failure';
    if ($args{debug}) {
      my $timestamp = localtime();
      print "$timestamp fetching list $user/$list_id ";
    }
    eval {
      $statuses = $nt->list_statuses({
        list_id => $list_id,
        user => $user,
        since_id => $high_water,
      });
    };
    unless ($@) {
      $result = 'success';
    }
    if ($args{debug}) {
      print " $result \n";
    }
  }

# default mode: follow the user's friends' timeline

  else {
    my $result = 'failure';
    if ($args{debug}) {
      my $timestamp = localtime();
      print "$timestamp fetching timeline > $high_water ";
    }
    eval {
      $statuses = $nt->friends_timeline({
        since_id => $high_water,
        count => 20,
      });
    };
    unless ($@) {
      $result = 'success';
    }
    if ($args{debug}) {
      print " $result \n";
    }
  }
  print_statuses($statuses);

  # if in follow mode, sleep and stay in loop
  # otherwise, exit the loop

  if ($args{follow}) {
    unless ($args{follow} >= 1) { $args{follow} = 1; }
    sleep $args{follow} * 60;
  }
  else {
    last;
  }
}

# purpose : print out the array of statuses in a formatted log-like fashion
# args    : $statuses_arrayref

sub print_statuses {
  my $statuses = shift;
  unless ($statuses) {
    return;
  }

  # print timestamp/separator

  if (scalar @$statuses && $args{timestamp}) {
    my $timestamp = '[ ' . localtime() . ' ] ';
    my $length_timestamp = length $timestamp;
    if ($args{color}) {
      print color 'blue';
    }
    print ' ' x (80  - ($length_timestamp + 1)) . ' ' . $timestamp . "\n";
    if ($args{color}) {
      print color 'reset';
    }
  }
  for my $status ( reverse @$statuses ) {
    $high_water = $status->{id};
    my $etime;
    eval { $etime = str2time $status->{created_at}; };
    #my $mins_ago = sprintf('%0.1f', (time - $etime) / 60);
    my $mins_ago = (time - $etime) / 60;
    my $mins_ago_print = sprintf '%02.1f', "$mins_ago";
    if ($mins_ago_print < 10) {
      $mins_ago_print = "0" . $mins_ago_print;
    }
    my $name_print = $status->{user}{screen_name};
    my $length_screen_name = length $name_print;
    if ($args{color}) {
      $name_colors{$name_print} ||= color($colors_foreground_screen_names[int(rand $#colors_foreground_screen_names + 1)]);
      $name_print = $name_colors{$name_print} . $name_print . color('reset');
    }
    #my $screen_name = sprintf '%-14s', $name_print;
    my $screen_name = ' ' x (14 - $length_screen_name) . $name_print;
    print $screen_name;
    if ($args{color}) {
      print color('blue');
    }
    print " | ";
    if ($args{color}) {
      print color('reset');
    }
    print encode 'utf8',  $status->{text};
    print "\n";
  }
}

